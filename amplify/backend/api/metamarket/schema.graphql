# @model directive creates CRUD operations and DynamoDB database tables (also adds the helper fields createdAt and updatedAt to your type)
type Nft @model @auth(rules: [
      { allow: public, operations: [read], provider: apiKey }
      { allow: owner }
  ]) {
    id: ID!
    name: String!
    price: Int!
    category: String!
    blockchain: String!
    colors: [String]
    xcoordinate: String
    ycoordinate: String
    description: String
    imageID: String!
    # This generates queries and mutations that allow you to retrieve the related Nft records from the source User record and vice versa. A field is automatically generated to reference the parentâ€™s primary key.
    user: User @belongsTo
}

type User @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  username: String!
  favorited: [Nft]
  # Under the hood, @hasMany configures a secondary index on the related table to enable you to query the related model from the source model.
  Nfts: [Nft] @hasMany
}

#type Nft @model @key(name: "ownedBy", fields: ["userID"]) @auth(rules: [
 #     { allow: public, operations: [read], provider: apiKey }
  #    { allow: owner }
  #]) {
   #id: ID!
    #name: String!
    #price: Int!
    #category: String!
    #blockchain: String!
    #colors: [String]
    #xcoordinate: String
    #ycoordinate: String
    #description: String
    #imageID: String!
    #userID: ID!
    #user: User @connection(fields: ["userID"])
#}

#type User @model @auth(rules: [{ allow: owner }]) {
  #id: ID!
  #username: String!
  #favorited: [Nft]
  #Nfts: [Nft] @connection(keyName: "ownedBy", fields: ["id"])
#}

