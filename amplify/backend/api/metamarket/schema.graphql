# @model directive creates CRUD operations and DynamoDB database tables (also adds the helper fields createdAt and updatedAt to your type)
type Nft @model @searchable @auth(rules: [
      { allow: public, operations: [read], provider: apiKey }
      { allow: owner }
  ]) {
    id: ID!
    name: String! @index(name: "byName", queryField: "nftByName",)
    price: Int! @index(name: "byPrice", queryField: "nftByPrice")
    category: String! @index(name: "byCategory", queryField: "nftByCategory")
    blockchain: String!
    colors: [String]
    xCoordinate: String
    yCoordinate: String
    description: String
    imageID: String!
    # This generates queries and mutations that allow you to retrieve the related Nft records from the source User record and vice versa. A field is automatically generated to reference the parentâ€™s primary key.
    user: User @belongsTo
}

type User @model @auth(rules: [{ allow: owner }]) {
  userId: String! @primaryKey
  username: String! @index(name: "byName", queryField: "userByUsername")
  favorited: [Nft]
  # Under the hood, @hasMany configures a secondary index on the related table to enable you to query the related model from the source model.
  Nfts: [Nft] @hasMany
}

